自我介绍

你好，我叫羊政钊 ，来自海南，曾在铭创通讯科技有限公司和青焱科技有限公司担任java开发的工作，
并工作了有三年，前后端都会，更擅长后端开发，最近做过的项目有新城市后台、研学官网、研学小程序、课后服务小程序等项目，
用到的技术有springboot、springsecurity、mybatis、mq、mysql、redis、zookeeper、dubbo、以及mycat、docker

在这些项目开发过程中，处理过并发下单问题，利用线程池异步编排优化接口，处理优化慢sql问题，
递归解决树表结构回显问题，以及实现身份切换，多方式登陆，研学课程入库，课程遴选，家长投票，课程推送家长等业务部分
这些项目都是saas化，支持多企业入驻，目前已有广州，佛山，江门等地区的学校和机构都在使用我们的平台

负责的部分很多，包括项目新功能的实现，旧功能优化的迭代，数据库表设计，线上bug处理


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

项目亮点
项目规模，项目业务背景，项目给社会创造的价值，遇到的挑战，项目成果，要量化(比如说你通过你的优化，
你的bug出现率从多少降低到多少，你的系统的运行性能从多少提升多少，这个个编码量多少)



1、解决过哪些特别复杂、有挑战性的问题
例如引入kafka消息队列优化了程序的效率，使得我们能够在高峰期处理百万级的消息
2、做了提高效率的工作
例如重构代码，优化数据库查询效率，引入异步线程，优化了代码的效率，开发了某个公共组件，提升了团队的开发效率（优化了一个复杂的慢sql语句，提高了数据库查询的效率，使得查询效率整体提升了10倍）
3、突出团队协作、沟通能力
例如在项目中承担了核心开发、团队小组长的角色，通过一系列的管理手段按时完成项目的交付和提高了质量保障 （我带领我的团队完成了这个项目，我负责分配任务，协调团队成员的工作以及解决团队中出现的问题。在我的管理下，我们成功的按时完成了项目，得到客户的高度评价）
4、突出学习能力
项目中要用到一个新技术，这个技术之前没有用过，但是项目交付时间比较紧，所以我大概花了三天时间在网上找了各种资料学习，在实际落地的时候还遇到了一下自己解决不了的问题，后面在在github的issus上找到了解决方案，最后按期完成了项目的交付

多次解决过cpu飙高的问题
内存溢出的问题
帮助团队排除并解决慢sql的问题


通过从
对业务设计的深度思考
问题解决能力
对某个特定技术的深入理解
团队协作沟通


1、负责项目需求分析，参与项目立项初期准备工作
2、负责项目的编码实现，配合测试，产品推进项目的落地
3、负责线上问题的维护，bug的处理
4、不断迭代，优化项目功能

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


你在项目里遇到的最大困难是什么，如何解决的？
在开发项目的时候，需要你实现一个你不熟悉的业务的时候是最难的，但是越是遇到这种情况也是最能提高自己能力的时候
对于这种情况我会先去明确需求，然后思考怎么完成，预估在实现过程会遇到什么难点，
然后明确难点接下来就是去针对这些难点去给出实现办法，最后把流程串联起来实现需求，最终功能实现后我也会做一下经验总结，下次在遇到就可以直接上手了




在项目中你有用到设计模式吗
有的，在项目中创建线程池的时候，我在封装异步任务管理器的时候，就是采用了单例模式创建对象，永远只创建一个异步管理器对象，然后我们通过它去调用它的方法-(实际上是对象里我们引入了线程池对象，通过它调用它自己的方法来实现我们的异步处理功能、异步延时处理功能等)


~`````````````````````````````````````````````````````````````````````~~~~`
java基础


什么是面向对象
面向对象包括封装、继承、和多态
封装：内部细节对外部调用透明，外部调用无需关心内部实现
继承：子类共性的方法或属性直接使用父类的，不需要自己再定义，自需扩展自己个性化的
多态是指类和类的关系，两个类有继承关系，存在有方法的重写，故而可以在调用时父类引用指向子类对象，多态必备三要素：继承，重写，父类引用指向子类对象


为什么有引用类型还用基本类型
基本数据类型占用存储空间小，可以把它们存入栈中，实现快速的操作。效率会更好些
而他们的封装类Integer等，必需创建实例，在堆中开辟内存，既消耗资源，又耗费时间。

既然这样，为什么不直接全部整成基本数据类型呢？
Java是一个面向对象的语言，然而基本数据类型不具备面向对象的属性。
当我们把基本数据类型包装成包装类型后，基本数据类型就具备了面向对象的属性。


Java反射的作用
对于任意一个类，可以知道这个类有哪些属性和方法。
对于任意一个对象，可以调用它的任意一个方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java 语言的反射



堆和栈的区别
堆的物理地址分配不连续，性能慢些
栈使用的是数据结构的栈，先进后出的原则，物理地址分配是连续的，性能快
堆分配的内存是在运行期确认的，大小不固定
栈分配的内存要在编译期就确认，大小是固定的
堆存放的是对象的实例和数组
栈存放的内存地址




单例模式-饿汉式

public class Singleton{
   public static final Singleton instance = new Singleton();

   private Singleton(){

   }
}
获取对象
Singleton s = Singleton.instance;


负载均衡的算法有哪些
轮询、加权、随机



为什么使用线程池
可以减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务，节省了开辟子线程的时间



sleep() 与 wait() 的区别
在等待时 wait会释放锁，并进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，而sleep会一直持有锁
wait()是object的方法，sleep()是线程类的方法


重写和重载的区别
重写：返回类型和形参不变，内容重写   外壳不变，核心重写
重载：返回类型可以不同，形参可以不同


抽象类和接口的区别
继承关系，成员方法，成员变量，静态代码块，静态方法去考虑
抽象类：单继承，成员方法可以实现细节，也可以写抽象方法，成员变量可以有多种可行，可以有静态代码块，和静态方法
接口：多实现，只能写抽象方法，成员变量只能是常量，不能有静态代码块和静态方法


静态变量和实例变量区别
加载方式、属于类还是类的对象去区别
静态变量由于不属于任何实例对象，属于类的；
在类的加载过程中，JVM只为静态变量分配一次内存空间

实例变量是属于实例对象的
每次创建对象，都会为每个对象分配成员变量内存空间


静态方法和实例方法的区别
调用方式、访问时去区别
调用静态方法时，可以"类名.方法名"的方式，也可以"对象名.方法名"的 方式
调用实例方法只能 "对象名.方法名"的 方式

静态方法访问本类的成员时，只能访问静态成员
实例方法则不限制


static存在的主要意义
即使没有创建对象， 也能使用属性和调用方法 !
只会在类加载的时候执行一次




equals与==的区别

==指内存地址是否相同。 equals()指的是值是否相同。



Java对象的创建过程

类加载检查
分配内存
初始化零值
设置对象头
执行 init 方法

在实例化一个对象的时候，jvm首先会去检查目标对象是否已经被加载并初始化，
如果没有，jvm需要去做的是立刻去加载目标类，就是把一个类加载到内存里面，然后去调用目标类的构造器去完成初始化，这个过程主要是对目标类里面的静态变量，成员变量，
静态代码块进行初始化，当目标类被初始化以后就可以从常量池里面去找到对应的类元信息了，并且目标类对象的大小在类加载完成之后就已经确定了，
所以这个时候就需要去为新创建的对象根据目标对象的大小在堆内存里面分配内存空间，
接下来jvm会去把目标对象里面的普通成员变量初始为0值，比如说int类型初始化为0，stirng类型初始化为null，
然后jvm还需要对目标对象的对象头做一些设置，比如对象所属的类元信息，对象的gc分代年龄，hashcode等等，
完成这些步骤以后对于jvm来说，新对象的创建工作已经完成了，但是对java语言来说对象创建才算刚刚开始，
接下来要做的就是执行目标对象内部生成的init方法，初始化成员变量的值，执行构造块，最后调用目标对象的构造方法去完成对象的创建

类加载检查，jvm会去检查有没有加载，如果没有jvm会去加载目标类，就是把一个类加载到内存中，然后调用目标类的构造器完成初始化，这个过程就是把目标类的静态变量等等初始化
分配内存，jvm会在堆内存里面分配内存空间给目标对象
初始化零值，jvm会把目标对象里面的普通成员变量初始化为0值，比如说int类型初始化为0，stirng类型初始化为null，
设置对象头，jvm会对目标对象做一些设置，比如对象的所属的类元信息，对象的gc分代年龄，hashcode等等
执行init方法，就是执行目标对象内部生成的init方法，初始化成员变量的值，执行构造块，最后调用目标对象的构造方法完成对象的创建



什么是浅拷贝，深拷贝
浅拷贝就是只复制指向某个对象的指针，而不是复制对象本身，新旧对象共享一块内存
深拷贝就是复制并创建一个一模一样的对象，不共享内存，修改新对象，旧对象保持不变


~`````````````````````````````````````````````````````````````````````~~~~`
spring

什么是spring
spring主要包括ioc容器和aop，
ioc是控制反转，把对象的创建和调用交由ioc容器管理，降低对象之间的依赖关系
aop是面向切面编程，可以将与业务不相关但是很多业务都要调用的代码抽取出来，不侵入原有代码的情况下对功能增强




bean初始化过程（生命周期）
1、实例化，调用无参构造方法
2、填充属性，也就是依赖注入
3、处理aware回调
4、其他步骤（初始化前 处理@postconstruct注解，初始化 处理initializingbean接口，初始化后(aop)）
5、加入到单例池map中
注：所谓的Bean的初始化，是站在Spring的角度，还需要对已经创建好的Bean进行后续的一些操作，
比如依赖注入之类的，这个过程会给Bean进行一些业务操作，成为一个真正的"成品"，可以即拿即用。


介绍下Spring IOC的工作流程
ioc的工作流程大致可以分为两个阶段，第一个阶段是ioc容器的初始化阶段，这个阶段主要是根据程序里面定义的xml或者注解等bean的声明方式，
通过解析和加载后生成Bean Definition，然后把Bean Definition注册到ioc容器里面，通过注解或者xml声明的bean都会解析得到一个Bean Definition实体，
这个实体里面会包含bean的一些定义和基本的一些属性，最后把这个Bean Definition保存到一个map集合里面，从而去完成ioc的一个初始化，
第二阶段是完成bean的初始化和依赖注入，通过反射去针对没有设置lazy-init属性的单例bean进行初始化，完成bean的依赖注入

主要分为两个阶段
ioc容器的初始化阶段和完成bean的初始化和依赖注入阶段
一、ioc容器的初始化阶段包括
1、Bean Definition的资源定位（宾得非内审），就是找到这些Bean定义文件(例如在xml定义的或者注解定义等)，并将这些信息抽象为统一的Resource对象，方便后面载入
2、Bean Definition的载入，载入过程其实是把用户定义好的Bean表示成IoC容器内部的数据结构
3、向IoC容器注册这些BeanDefinition，是注入到一个HashMap中去，IoC容器就是通过这个HashMap来持有这些BeanDefinition数据的。
注：BeanDefinition实际上就是POJO对象在IoC容器中的抽象，通过这个BeanDefinition定义的数据结构，使IoC容器能够方便地对Polo对象也就是Bean进行管理。
二、完成bean的初始化和依赖注入阶段
就是通过反射去针对没有设置lazy-init属性的单例bean进行初始化，完成bean的依赖注入


Spring 的 IoC 的实现原理就是工厂模式加反射机制



IoC容器的初始化过程
1、Bean Definition的资源定位（宾得非内审）

2、Bean Definition的载入，载入过程其实是把用户定义好的Bean表示成IoC容器内部的数据结构

3、向IoC容器注册这些BeanDefinition，是注入到一个HashMap中去，IoC容器就是通过这个HashMap来持有这些BeanDefinition数据的。

注：BeanDefinition实际上就是POJO对象在IoC容器中的抽象，通过这个BeanDefinition定义的数据结构，使IoC容器能够方便地对Polo对象也就是Bean进行管理。


spring的事务是如何实现的
基于数据库事务和aop机制实现
首先对使用@transactional注解的bean，会创建一个代理对象
当调用代理对象的方法时，判断该方法是否加了@ transactional注解
如果加了，利用事务管理器创建一个数据库连接
修改数据库连接的自动提交属性为false
然后执行当前方法，方法会执行sql
执行完当前方法后，如果没有出现异常直接提交事务
如果出现异常，并且这个异常是需要回滚的会回滚事务，否则任然提交事务



Srping的AOP底层实现
采用的是代理技术，代理的方式有基于JDK的动态代理 或者 基于CGLIB动态代理：


JDK动态代理的核心是InvocationHandler接口和Proxy类，在获取代理对象时使用Proxy类来动态创建目标类的代理类，当代理对象调用真正对象的方法时，
InvocationHandler(英沃k审handler) 通过invoke()方法反射来调用目标类的代码，动态地将横切逻辑和业务编织在一起；

而CGLIB是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP


beanfactory与applicationcontext有什么区别

延迟加载 ，某个属性没有注入，只有当调用的时候才会发现没有注入并抛出异常
而是在初始化时就会自身检验，检查所依赖属性是否注入

applicationcontext与beanfactory相比，提供了更多的扩展功能，例如事件发布，国际化支持等功能
beanfactory是延迟加载，如果bean的某个属性没有注入，beanfactory加载后直至第一次使用调用getbean方法才会抛出异常；
而applicationcontext则在初始化自身时检验，这样有利于检查所依赖属性是否注入，所以通常情况下我们会选择使用applicationcontext



spring Bean如何保证并发安全？
1、可以设置bean的作用域设置为原型，这样每次从容器中获取该bean时，都会创建一个新的实例，避免多线程共享同一个对象实例的问题
2、在不改变bean的作用域的情况下，可以避免在bean中存在可变状态的声明，可以尽量将状态信息存储在方法内部的局部变量中，或者使用线程安全的数据结构来管理状态
3、使用java并发编程中提供的同步锁机制来保证并发安全性，来控制对共享状态的访问，从而去确保在同一个时刻只有一个线程可以去修改状态


spring中的单例bean的线程安全问题了解吗
单例bean存在线程安全问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题
解决方案：在类中定义一个threadlocal成员变量，将需要的可变成员变量保存在threadlocal中



16.ThreadLocal原理
原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。
但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。
所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value







mybatis的一级、二级缓存
Mybatis的一级缓存是一个SqlSession级别的缓存，只能访问自己的一级缓存数据，而二级缓存是Mapper级别的缓存，是跨SqlSession的，不同的SqlSession是可以共享缓存数据的。

一级缓存的具体实现原理是:
在 SqlSession 里面持有一个 Executor，每个 Executor 中有一个 LocalCache 对象。 当用户发起查询的时候，
Mybatis 会根据执行语句在 Local Cache 里面查询，如果没命 中，再去查询数据库并写入到 LocalCache，否则直接返回。
二级缓存的具体实现原理是:
使用 CachingExecutor 装饰了 Executor，所以在进入一级缓存的查询流程之前，会先 通过 CachingExecutor 进行二级缓存的查询。
开启二级缓存以后，会被多个 SqlSession 共享，所以它是一个全局缓存。因此它的查 询流程是先查二级缓存，再查一级缓存，最后再查数据库


spring的缓存机制
一级缓存：单例池，存储完整的bean实例，这些实例是可以直接被使用
二级缓存：存储的实例以后但是还没有设置属性值的bean实例，也就是bean里面的依赖注入还没有做
三级缓存：用来存放bean工厂，主要用来生成原始bean对象并且放到第二个缓存里面，三级缓存的核心思想是把bean的实例化和bean里面的依赖注入进行分离，
采用一级缓存存储完整的bean实例，采用二级缓存存储不完整的bean实例，通过不完整的bean实例作为突破口，解决循环依赖问题



如何解决循环依赖呢？
通过 @Lazy 注解进行懒加载

Spring 是如何解决循环依赖？
使用三级缓存和提前暴露未完成的Bean，这样，即使存在循环依赖，Spring也能够确保依赖的Bean在正确的时间点被注入，避免了循环依赖导致的无限递归或空指针异常等问题。
三级缓存的作用：为了打破循环


12.spring事务的传播行为
测试用例：
	@Transactional
	public void add() {
		KsA ksA = new KsA();
		ksA.setName("林");
		ksAService.insert(ksA);
		KsB ksB = new KsB();
		ksB.setAge(10);
		ksBService.insertError(ksB);
		throw new RuntimeException("父方法报错");
	}


	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void insertError(KsB ksB) {
		ksBDao.insert(ksB);
		throw new RuntimeException("子方法报错");
	}


默认：当前存在事务，则加入这个事务,如果当前没有事务，则自己新建一个事务，
当A调用B的时候：如果A中没有事务，B中有事务，那么B会新建一个事务；如果A中也有事务、B中也有事务，那么B会加入到A中去，变成一个事务（一起成功，一起失败）

当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行
如果A中有事务，则B方法的事务加入A事务中，成为一个事务（一起成功，一起失败），如果A中没有事务，那么B就以非事务方式运行（执行完直接提交）

当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。
如果A中有事务，则B方法的事务加入A事务中，成为一个事务（一起成功，一起失败）；如果A中没有事务，B中有事务，那么B就直接抛异常了，意思是B必须要支持回滚的事务中运行

创建一个新事务，如果存在当前事务，则挂起该事务。
B会新建一个事务，A和B事务互不干扰，他们出现问题回滚的时候，也都只回滚自己的事务；

以非事务方式执行,如果当前存在事务，则挂起当前事务
被调用者B会以非事务方式运行（直接提交），如果当前有事务，也就是A中有事务，A会被挂起（不执行，等待B执行完，返回）；A和B出现异常需要回滚，互不影响

不使用事务，如果当前事务存在，则抛出异常

如果当前事务存在，则在嵌套事务中执行，否则（开启一个事务）
如果A中没有事务，那么B创建一个事务执行，如果A中也有事务，那么B会会把事务嵌套在里面。


非事务的方式运行，其实就是设置为自动提交



Spring支持的几种bean的作用域
 5种
（1）singleton：默认作用域，单例bean，每个容器中只有一个bean的实例。

（2）prototype：为每一个bean请求创建一个实例。

（3）request：为每一个request请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。

（4）session：同一个session会话共享一个实例，不同会话使用不同的实例。

（5）global-session：全局作用域，所有会话共享一个实例。





Spring基于xml注入bean的几种方式
Set方法注入；
构造器注入：
通过index设置参数的位置；
通过type设置参数类型；
静态工厂注入；
实例工厂




springmvc原理
前端控制器接收用户请求将请求发送给处理器映射器handlerMapping;
处理器映射器handleMapping根据请求url找到具体handler返回给前端控制器;
前端控制器调handle适配器去执行具体的controller,并将controller返回的modelAndView返回给前端控制器；
前端控制器将modelAndView传给视图解析器去解析，解析后返回具体的视图，前端控制器根据视图进行渲染返回给用户；




Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？
        不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；
        原因就是namespace+id是作为Map的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。


MyBastis如何映射
Mybatis可以把Mapper.xml文件直接映射到对应的接口，调用接口方法会自动去Mapper.xml文件中找到对应的标签，这个功能就是利用java的动态代理



~`````````````````````````````````````````````````````````````````````~~~~`

springboot

Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？
@SpringBootApplication

由@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan组成


Spring Boot 有哪几种读取配置的方式？
Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注
解来绑定变量


Spring Boot 中如何解决跨域问题 ?
可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。


@Autowired和@Resource之间的区别
@Autowired默认是按照类型装配注入的
@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来
装配注入。


什么是springboot自动配置
SpringBoot通过@EnableAutoConfiguration注解开启自动配置，对jar包下的spring.factories文件进行扫描，
这个文件中包含了可以进行自动配置的类，当满足条件装配的情况，便在依赖的支持下进行实例化，注册到Spring容器中。

简单来说就是自动去吧第三方组件的bean装载到ioc容器里面，


自动装配的实现主要依靠三个核心的关键技术，
第一个引入starter，启动依赖组件的时候这个组件里面必须要包含一个@Configuration配置类，而这个配置类里面我们需要通过@bean这个注解去声明需要装配到ioc容器里面的bean对象，
第二个是这个配置类是放在第三方的jar包里面，然后通过springboot中约定优于配置的这样一个理念，去把这个配置类的全路径放在spring.factories文件里面，
这样的话springboot就可以知道第三方jar包里面这个配置类的位置，
第三个是springboot拿到所有第三方jar包里面声明的配置类以后在通过spring提供的importSelector这样一个接口来实现对这些配置类的动态加载，从而去完成自动装配这样一个动作

1、用途不同
2、使用方式不同
3、控制权不同
@component注解：用于标识一个普通类；这个注解是一个类级别的注解，通过@ComponentScan注解扫描并注册为bean；是由spring框架来创建和初始化的


@bean注解：是用于在配置类中声明和配置bean对象；这个注解是方法级别的注解使用，在配置类中手动声明和配置bean；允许开发人员手动控制bean的创建和配置过程，更灵活



如何在springboot项目启动后执行某些操作。
可以通过实现ApplicationRunner接口，然后在run方法里面调用需要调用的方法即可


如何使用 Spring Boot 实现全局异常处理？
通过实现一个ControlerAdvice 类，来处理控制器类抛出的所有异常


10.@Async注解的原理，可能引发的问题？
实现原理：默认异步配置使用的是SimpleAsyncTaskExecutor去处理，该线程池默认来一个任务创建一个线程，达不到线程复用的功能，
最终会导致系统占用内存过高，因此当我们使用@Async时我们都会手动自定义线程池，通过重新实现接口AsyncConfigurer或者继承AsyncConfigurerSupport



dubbo是rpc  openfeign是http
openfeign基于Http传输协议，短连接，不适合高并发的访问。
Dubbo是利用Netty，TCP传输，单一、异步、长连接，适合数据量小、高并发和服务提供者远远少于消费者的场景。



~`````````````````````````````````````````````````````````````````````~~~~`

redis


缓存穿透：指频繁请求缓存中不存在的数据，缓存永远不会生效，请求都到达了数据库
解决办法：在接口上做基础校验；使用布隆过滤器-客户端和缓存之间添加一个过滤器，拦截掉一定不存在的数据请求

缓存击穿：指一个热点key在某一瞬间失效，导致大量请求到达数据库
解决办法：设置热点key永久不过期

缓存雪崩：指某一时间key同时失效或redis宕机，导致大量请求到达数据库
解决办法：搭建集群保证高可用；进行数据预热，给不同key设置随机过期时间

redis数据类型
string  底层实现方式：动态字符串sds 或者 long(String类型的value的值是数字，那么Redis内部会把它转成long类型来存储)
	为什么使用动态字符串：内存预分配，优化字符串的增长操作；惰性空间回收，优化字符串的缩短操作

hash  底层实现方式：压缩列表ziplist(刚开始当数据量较少的情况下) 或者 字典dict
	为什么使用dict:因为当数量变大，ziplist如果查找需要进行遍历，性能变得很低；每次插入或修改引发的realloc操作，
	造成内存拷贝，从而降低性能。而dict本质上是为了解决算法中的查找问题，是一个基于哈希表的算法，查询的时间复杂度接近O(1)



set 底层实现方式：有序整数集合intset(刚开始当数据量较少的情况下) 或者 字典dict
zset 底层实现方式：ziplist(刚开始当数据量较少的情况下)或skiplist
	为什么使用ziplist：ziplist使用一块连续的内存空间来存储数据，并采用可变长的编码方式，支持不同类型和大小的数据的存储，更加节省内存，读取的效率也非常高

list 底层实现方式：quicklist(基于ziplist的双向链表，quicklist的每个节点都是一个ziplist)


redis持久化机制
（1）快照持久化RDB

redis的默认持久化机制，通过在某个时间点将数据写入一个临时文件持久化结束后，用这个临时文件替换上次持久化的文件达到数据恢复。
可以通过配置文件中的save参数来定义快照的周期。所以RDB的优点是保证redis性能最大化，恢复速度数据较快，
缺点是在持久化时Redis发生故障，会发生数据丢失，所以这种方式更适合数据要求不严谨的时候；


（2）追加持久化AOF

以日志形式记录每一次的写入和删除操作，当重启Redis会重新将持久化的日志中文件恢复数据，优点是数据完整性高，缺点是运行效率低，恢复时间长


Redis为什么这么快？
完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，避免了通过磁盘IO读取到内存这部分的开销
数据结构简单，对数据操作也简单，可以提升读取和写入的性能。
采用单线程，省去了很多上下文切换的时间以及CPU消耗
使用基于IO多路复用机制的线程模型，可以处理并发的链接



怎样保证redis的缓存和数据库数据一致性
延迟双删（先删除redis）
先删除redis缓存数据，再更新mysql，延迟几百毫秒在删除redis缓存数据，这样就算在更新mysql时，有其他线程读取mysql，把旧数据读到redis，那么也会被删除掉，从而保证数据最终一致


队列+重试机制  （先删除mysql）
更新数据库数据，缓存因为种种问题删除失败，将需要删除的key发送到消息队列，自己消费消息，获取需要删除的key，继续重试删除操作，直到成功




~`````````````````````````````````````````````````````````````````````~~~~`

分布式

redis分布式锁的实现原理
首先利用setnx来保证：如果key不存在才能获取锁，如果存在，则获取不到锁
然后利用lua脚本保证多个redis操作的原子性
同时考虑锁的过期，需要额外的一个看门狗定时任务来监听锁是否需要续约
同时考虑节点挂掉后，需要采用红锁的方式来同时向n/2+1节点申请锁，都申请到了才证明获取锁成功，
这样如果其中一个节点挂掉了，锁也不会影响其他客户端获取到



Redis分布式锁的实现原理
原理是使用setnx+setex命令来实现，但是会有一系列问题：

（1）任务时常超过缓存时间，锁自动释放。可以使用Redision看门狗解决

（2）加锁和释放锁的不是同一线程。可以在Value中存入uuid，删除时进行验证。但是要注意验证锁和删除锁也不是一个原子性操作，可以用lua脚本使之成为原子性操作

（3）不可重入。可以使用Redision解决（实现机制类似AQS,计数）

（4）redis集群下主节点宕机导致锁丢失。使用红锁解决




分布式事务（2pc两阶段提交协议、tcc方案）
采用2pc两阶段提交协议  阿里框架seata AT模式(即2PC)

优点是性能较好，且不长时间占用连接资源 ，高效并且对业务0侵入

TC： 事务协调器 (Seata)
TM:  事务管理器（注解@）
RM:  资源管理器（数据库实例）

执行步骤：
开启全局事务，返回xid
注册分支事务，将其纳入xid对应的全局事务以此类推其他服务也注册分支事务
都完毕后，发起针对xid的全局提交和回滚决议
调度xid下的全部分支事务完成提交或回滚

事务管理器向事务协调器开启全局事务，成功返回xid
资源管理器向事务协调器注册分支事务，将其纳入xid对应全局事务
以此类推，其他服务也注册分支事务
都执行完毕后事务管理器向事务协调器发起针对xid的全局提交和回滚决议
事务协调器调度xid下的全部分支事务完成提交或回滚



tcc方案
try阶段  confirm阶段   cancel阶段
有几个异常要处理
一、空回滚（由于没有执行try先执行cancel，需要在cancel阶段判断是否已经执行了try）
二、幂等问题（因为会用重试机制，需要在try、confirm、cancel阶段都判断）
三、悬挂问题（由于没有执行try先执行cancel或confirm，需要在try阶段判断如果cancel、confirm有一个已经执行了，try不再执行）





什么时候会使用分布式锁
一般项目中都可以使用分布式锁或者用java的
synchronized以及lock类来实现加锁，但是如果是分布式的集群环境下是必须要使用分布式锁来保证不同节点的线程同步执行

为什么分布式的集群环境要使用分布式锁？
本质原因是集群状态下，不同的服务器的jvm不一致，由不同的锁监视器来控制锁的生成和释放，导致锁失效





~`````````````````````````````````````````````````````````````````````~~~~`

mysql


mysql事务的实现原理
mysql里面的事务满足acid特性，所以mysql的事务原理在我看来就是innodb如何保证acid这样一个特性的。
首先 a表示原子性，也就是说事务中的操作是不可分割的，要么都成功，要么都失败，那么失败就意味着对原本执行成功的数据要进行回滚，所以innodb里面设计了一个undo_log表，在事务执行的过程中把修改之前的数据快照保存到undo_log里面，一旦出现错误，就直接从undo_log里面去读取数据，进行反向操作就行了，
其次c表示一致性，也就是说事务执行前后的数据的完整性保持一致，那么这个呢更多是依赖业务层面的一些保障，数据库本身也提供一些比如说像主键的唯一约束，字段长度和类型的一些保障等。
接下来i表示事务的隔离性，也就是说一个事务执行的过程中，不应受到其他事务的影响的一个问题，而innodb里面呢实现了sql92的一个标准，提供了四种隔离级别的一个实现，分别是读未提交，读已提交，可重复读，串行化，innodb默认采用的隔离级别是可重复读，然后使用了mvcc机制去解决了脏读和不可重复读的一个问题，然后使用了行锁/表锁的方式来解决了幻读的问题，
最后d表示持久性，也就是说事务执行完后，数据要永久的保存，不能因为数据库宕机或者其他原因导致数据变更的一个失效，理论上说事务提交完后直接把数据直接放到磁盘里面就ok了，但是因为随机磁盘io的效率很低，所以innodb里面设计了buffer pool缓冲区来进行优化，也就是说数据发生变更的时候先更新内存缓冲区然后在合适的时间再持久化到磁盘里面，那么在这个机制里面有可能出现持久化的这样一个过程中如果数据库宕机就会导致数据丢失，也就是说无法区满足持久化，所以在innodb里面引入了redo_log这样一个文件，这个文件存储了数据库变更之后的一个值，当我们通过事务进行数据更改的时候，除了修改内存缓冲区里面的数据以外，还会把本次修改的一个值追加到redo_log里面，当事务提交的时候直接把redo_log里面的日志刷新到磁盘里面进行持久化，一旦数据库出现宕机在mysql重启以后可以直接用redo_log里面保存的重写日志读取出来以后再去执行一遍，从而去保证数据的一个持久性，因此在我看来事务的原理核心本质就是如何去保证事务的acid特性，而在里面用到了mvcc、行锁、表锁、undo_log以及redo_log等等这样一个机制，去保证这样的一个特性


因为mysql事务满足acid特性，所以事务的实现原理其实就是innodb如何保证acid的特性
首先a是原子性，事务中的操作是不可分割的，要么都成功要么都失败，那么失败意味着要回滚，而innodb设计了undo_log表，
在修改前先把数据保存到undo_log表，一旦出错，读取undo_log表，反向操作
其次c是一致性，事务执行前后的数据完整性保持一致，那么这个更多依赖业务层面的一些保障，数据库本身也提供一些比如主键的唯一约束，字段类型和长度的一些保障等
接下来i是隔离性，一个事务执行过程中，不受其他事务的影响，而innodb实现了sql92标准，提供四种隔离级别，读未提交，读已提交，可重复读，串行化，
默认隔离级别可重复读，然后使用mvcc机制解决脏读，不可重复读的问题，使用表锁、行锁解决幻读问题
最后d是持久化，就是事务执行完后数据要永久保存，所以innodb设计了内存缓冲区和redo_log表来提高效率和保证数据不会丢失问题，
一旦数据库宕机重启可以直接用redo_log里面保存的重写日志读取出来以后再去执行一遍，从而去保证数据的一个持久性






为什么不使用select *
因为select * 会走全表扫描，没有用到任何索引，查询效率非常低，
如果查询列都是索引列那么这些列表被称为覆盖索引，这种情况下查询的相关字段都能走索引，索引查询效率相对较高


你了解sql的执行顺序吗？
from->on->join ->where->group by -> 聚合函数 ->分组过滤函数 ->select ->distinct去重
->order by ->分页 ->


MylSAM和InnoDB的区别
MylSAM： mysql5.5之前的存储引擎，是表锁（悲观锁）级别的，不支持事务和外键。
InnoDB： mysql5.5之后的存储引擎，是行锁（乐观锁）级别的，支持事务和外键。


为什么推荐使用整形自增主键
它对插入效率更高，不会时不时的导致节点的分裂影响sql的执行效率






怎么优化数据库
①SQL优化
②加缓存
③分库分表
④读写分离


char和varchar的区别
①char设置多少长度就是多少长度，varchar可以改变长度
③char适用于固定长度的字符串，比如身份证号、手机号等，varchar适用于不固定的字符串。



索引的优点：

减少查询需要检索的行数，加快查询速度，避免进行全表扫描


什么时候会使用索引
WHERE子句中经常出现的列上面创建索引，加快条件的判断速度
经常用于连接的列上，这些列主要是一些外键，可以加快连接的速度；
作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
在group by或order by中使用的列，因为索引已经排序，这样可以利用索引加快排序查询时间。



delete、truncate、drop的区别
truncate和delete只删除数据，不删除表结构，drop删除表结构，并且释放所占的空间
不需要该表时，用drop
当仍要保留表，但要删除所有记录时，用truncate
当你删除部分记录时，用delete




事务的隔离级别
读未提交：出现脏读
读已提交：避免脏读，但会出现不可重复读和幻读
可重复读：避免脏读、不可重复读，但会出现幻读 mysql默认的隔离级别
串行化：最严格的事务隔离级别 效率低


并发事务带来的问题
更新丢失、出现脏读、不可重复读、幻读




事务的acid
原子性：事务中的操作是不可分割的
隔离性：一个事务执行的过程中，不应受到其他事务的影响
持久性：事务执行完后，数据要永久的保存
一致性：事务执行前后的数据的完整性保持一致


#{} 和 ${} 的区别
{}是预编译处理，${}是字符串替换。

说一说三个范式
第一范式: 每个列都不可以再拆分.
第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的 一部分.
第三范式: 非主键列只依赖于主键,不依赖于其他非主键。
事实上 我们在设计数据库结构的时候经常 会为了性能而妥协数据库的设计。






7.MySQL有哪些索引
主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值

唯一索引：唯一索引不能有相同值，但允许为空

普通索引：允许出现重复值

组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则

全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎




9.MySQL如何做慢SQL优化

避免全表扫描，在 where 及 order by 涉及的列上建立索引
能用between就不要用in了
只查询一条数据的时候使用limit 1
对于联合索引来说，要遵守最左前缀法则,否则索引失效.
避免在where子句中对字段进行函数操作，导致引擎放弃使用索引而进行全表扫描
避免在where子句中对字段进行null值判断，否则会放弃使用索引而进行全表扫描
避免使用范围查询语句，会导致放弃走索引，自动变成全表扫描。
避免在 where 子句中使用 or 来连接条件，会导致引擎放弃使用索引而进行全表扫描


可以通过
1、优化查询的选择条件、连接和排序操作
2、优化查询中的使用的索引，包括创建新索引，删除无用索引，调整索引顺序等
3、优化查询中使用的表连接方式，包括内连接，外连接，自连接等
4、优化查询中使用的子查询，包括对子查询进行优化，使用连接代替子查询等
5、优化查询中使用的聚合函数，包括使用索引进行优化，使用分组连接代替聚合函数等


可以几个方面入手
1、使用的选择条件、排序操作
2、使用的索引，包括创建新索引，删除无用索引，调整索引顺序
3、使用的表连接，包括内连接，自连接，外连接
4、使用的子查询，包括可以使用表连接代替子查询
5、使用的聚合函数，包括可以使用分组连接代替聚合函数



14.B和B+数的区别，为什么使用B+数
二叉树：索引字段有序，极端情况会变成链表形式

AVL数：树的高度不可控

B数：控制了树的高度，但是索引值和data都分布在每个具体的节点当中，若要进行范围查询，要进行多次回溯，IO开销大

B+树：非叶子节点只存储索引值，叶子节点再存储索引+具体数据，从小到大用链表连接在一起，范围查询可直接遍历不需要回溯7


为什么mysql使用b树做索引而不是红黑树？
因为索引很大，通常作为文件存储到磁盘上面，所以磁盘io的次数是衡量索引数据结构好坏的重要标准，而b树控制了高度，树越扁，磁盘io次数越少，
性能更好，而b+树去掉了节点内data域，有更大的宽度，性能比b树更好


为什么b树，它的整个高度 会相比二叉树来说，会矮很多
 B 树是一种多路平衡查找树，它满足平衡二叉树的规则，但是它可以有多 个子树，子树的数量取决于关键字的数量
因此从这个特征来看，在存储同样数据量的情况下，B 树的高度相对会矮很多



24.MySQL插入百万级的数据如何优化？
（1）一次sql插入多条数据，可以减少写redolog日志和binlog日志的io次数（sql是有长度限制的，但可以调整）

（2）保证数据按照索引进行有序插入

（3）可以分表后多线程插入




innoDB 如何解决幻读
通过间隙锁的方式解决了幻读问题，但是加锁之后一定会影响到并发性 能，因此，如果对性能要求较高的业务场景中，可以把隔离级别设置成 RC级别，这个级别 中不存在间隙锁。

什么是间隙锁？
间隙锁是在索引记录之间的间隙上的锁；
间隙锁通过锁住一个范围，如果其他事务想要在这个范围内插入该范围不存在的数据时就会被阻塞。

InnoDB采用了MVCC多版本控制的方式来实现RC和RR
RC下：语句级的多版本，即一个事务的多条只读语句，创建不同的版本，可以读到其他事务已提交的数据。

RR下：事务级的多版本，即一个事务只有一个版本，所以读不到其他事务已提交的数据（只有一个版本）。



数据库的三种并发场景
第一种:读读
不会出现任何并发问题
第二种:读写
会出现事物隔离性问题，出现脏读，幻读，不可重复读的问题
第三种:写写
可能会存在数据更新丢失的问题。
而 MVCC 就是为了解决事务操作中并发安全性问题的无锁并发控制技术

MVCC 的底层原理
通过数据库记录 中的隐式字段，undo_Log 日志 ，Read View 来实现的。
隐式字段：3个
	DB_ROW_ID：隐含的自增ID；
	DB_TRX_ID：记录最近修改这条记录的事务ID；
	DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本
undo_Log：将之前的操作都记录下来，适当时候进行回滚
ReadView：读视图，即事务进行快照读时刻，生成的数据库记录的快照

整体执行流程
1、首先获取事务自己的版本号，也就是事务ID
2、获取readview
3、查新 得到的数据，然后与readview中的事务版本号进行比较
4、如果不符合readview规则，就需要从undolog中获取历史快照
5、最后返回符合条件的数据

MVCC 主要解决了三个问题
 第一个是:通过 MVCC 可以解决读写并发阻塞问题从而提升数据并发处理能力
 第二个是:MVCC 采用了乐观锁的方式实现，降低了死锁的概率
 第三个是:解决了一致性读的问题也就是事务启动时根据某个条件读取到的数据，
直到事务结束时，再次执行相同条件，还是读到同一份数据，不会发生变化。
在使用 MVCC 时一般会根据业务场景来选择组合搭配乐观锁或悲观锁。 这两个组合中，MVCC 用来解决读写冲突，乐观锁或者悲观锁解决写写冲突从而最大 程度的提高数据库并发性能。



什么是聚集索引和非聚集索引
聚集索引就是基于主键创建的索引，除了主键索引以外的其他索引，称 为非聚集索引


~`````````````````````````````````````````````````````````````````````~~~~`
数据结构


list(线性结构)
arraylist底层是数组，线程不安全，查询快，数组长度默认是10，按1.5倍进行扩容，连续内存空间

它是如何实现扩容的
首先创建一个新的数组，这个新数组的长度是是原来数组长度的1.5倍，然后使用arrays.copyOf方法把老数组里面的数据拷贝到新数组里面，
扩容完成后再把当前需要添加的元素加入到新的数组里面，从而去完成动态扩容的一个过程


linkedlist底层是双向链表，插入和删除时效率高，线程不安全 ，无需扩容
vector 底层结构是数组，，是线程安全的，增删查都慢，扩容默认增长原来的2倍，可以指定增长空间长度


map(k,v对)
hashmap底层是数组加链表加红黑树，线程不安全，允许k/v都为null，默认长度是16，并且默认长度和扩容后的长度都必须是2的幂
hashtable底层是链地址法组成的哈希表(即数组+单项链表)，使用了synchronized关键字，线程安全
ConcurrentHashMap是线程安全的hashmap，不允许k/v都为null，1.7采用分段锁的形式加锁，1.8使用synchronized和cas实现同步
为什么不允许k/v都为null
是为了去避免在多线程并发场景下的一个歧义问题，也就是当一个线程从ConcurrentHashMap去获取key的时候，如果返回的结果是null，
那么这个线程是无法确认这个null表示的是确实不存在这个key还是说存在这个key但是value为空，这种不确定性会造成线程安全性问题，
而ConcurrentHashMap本身又是一个线程安全的集合，所以才有了这样一个设计

LinkedHashMap是继承自hashmap，所以底层任然是基于数组和链表或红黑树组成，因为LinkedHashMap在上面结构的基础上增加了一条双向链表，使得可以保证键值对的插入顺序

set(唯一值)
hashset底层是hashmap，使用了hashmap的k作为元素存储,V为new Object(),在add()方法中如果两个元素的hash值相同，
则通过equals方法比较是否相等，允许空值，不是线程安全的，不重复，无序

LinkedHashSet是一个基于LinkedHashMap实现。
没有重复，有顺序，维护了添加顺序，可以存储null值，线程不安全

LinkedHashSet是如何保证唯一和有序的
根据元素的hashCode值来决定元素的存储位置,同时使用链表维护元素的次序, 这使得元素看起来是以插入顺序保存的。

因为LinkedHashSet是基于LinkedHashMap实现，而LinkedHashMap又是基于hashmap的基础上加上双向链表，
而hashmap底层又是基于数组加链表加红黑树


treeset 红黑树实现有序唯一，通过自然排序和比较器排序保证元素有序，根据比较返回值是否是0保证元素唯一



hashmap什么时候会转成红黑树
当链表长度大于8并且数组长度大于64时，才会转换为红黑树，之前还是一直保持链表的形式

数组默认大小16，可以降低hash碰撞的几率

加载因子0.75，其实是出于容量和性能之间平衡的结果，设置比较大的时候时Hash冲突的几率就会提升；设置比较小的时候虽然Hash冲突的几率变小但是会占用更多的空间

采用2倍扩容，可以尽可能的减少元素位置的移动

HashMap的扩容操作是怎么实现的？


HashMap 是怎么解决哈希冲突的
HashMap和其他基于map的类都是通过链式寻址法解决冲突，当出现hash冲突的时候就会把存在 hash 冲突 的 key，以单向链表的方式来存储
当 hash 冲突比较多的时候，会造成链表长度较长，这种情况会使得查询复杂度变成 O(n)，引入了 红黑树的机制，优化 Hash 表链表过长导致时间复杂度增加的问题


为什么使用红黑树
因为红黑树用很好的自平衡，他可以通过左旋。右旋。变色来保持相对平衡，一个平衡的树，通过平衡二分查找效率会提高很多

为什么使用红黑树
如果是二叉搜索树的话，极端情况有可能所有的节点有可能都会在一个方向，如果是这种结构的话跟链表没啥区别
引入了红黑树的目的：是因为红黑树有很好自平衡，红黑树相比avl树(平衡二叉树)，在检索的时候效率其实差不多，都是通过平衡来二分查找。但对于插入删除等操作效率提高很多

为什么红黑树可以保持相对平衡
红黑树是通过左旋，右旋，变色操作来保持平衡

左旋就是将节点的右子树提升为父节点
右旋则将一个节点的左子树提升为其父节点，以保持树的平衡
通常旋转操作用在插入和删除操作
变色就是例如保证相邻节点不同时为红色



数组没有 length()方法，而是有 length 的属性。String 有 length()方法。

String 是基本数据类型吗?
String 是引用类型，由 char[] 数组构成，使用了 final 修饰，是不可变对象，可以理解为常量，线程安全

string、stringbuffer、stringbuilder
string是不可变的
而stringbuffer和stringbuilder表示的字符串对象可以直接进行修改
stringbuilder  线程不安全 性能较高
stringbuffer   线程安全 性能较差


~`````````````````````````````````````````````````````````````````````~~~~`
mq



如何保证消息不丢失
做好消息确认机制
每一条消息都要记录到数据库
消费者正常消费完，mq不再向消费者推送消息，做好幂等操作


消息重复消费如何处理
业务消费接口设计为幂等性

消费者的业务消费接口设置为幂等性，可以处理完消息添加一条记录，通过查有没有记录，处理过就不用处理了


如何防止消息积压
上线更多的消费者，进行正常消费或者上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理






~`````````````````````````````````````````````````````````````````````~~~~`
jvm
什么是java垃圾回收机制
是指在jvm中，有一个垃圾回收线程，他是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，
并将他们添加到要回收的集合中，进行回收

如何判断一个对象是否存活
1、引用计数法，每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，计数器加一，引用失效时，计数器减一，当一个对象的引用计数器为零时，
说明该对象没有被引用，将会被垃圾回收，但是引用计数法有一个缺陷就是无法解决循环引用问题，所以主流的虚拟机都没有采用这种算法
2、引用链法，从一个被称为gc roots的对象开始向下搜索，如果一个对象到gc roots没有任何引用链相连时，则说明此对象不可用了


垃圾回收器的基本原理
就是gc采用有向图的方式记录和管理堆中的所有对象，来确定哪些对象是可达的，哪些对象是不可达的，当gc确定一些对象是不可达时，gc就有责任回收这些内存空间





JVM调优命令有哪些?

jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。

jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。

jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出 虚拟机进程 中的类装载、内存、垃圾收集、JIT编译等运行数据。


2.什么情况下会内存溢出？
堆内存溢出：（1）当对象一直创建而不被回收时（2）加载的类越来越多时（3)虚拟机栈的线程越来越多时

栈溢出：方法调用次数过多，一般是递归不当造成


~`````````````````````````````````````````````````````````````````````~~~~`
java锁

synchronized的原理是什么
synchronized实现原理就是通过在对象头设置标记，达到获取锁和释放锁的目的。
他是如何标记的？
在被synchronized修饰过的程序块，在编译前后被编译器生成了monitorenter和monitorexit两个字节码指令，在虚拟机执行到monitorenter指令时，
首先要尝试获取对象的锁：如果这个对象没有锁定，把锁的计数器+1；当执行monitorexit指令时将锁计数器-1；当计数器为0时，
锁就被释放了，如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。


这里说的对象锁其实本质是monitorenter和monitorexit字节码指令的一个reference类型的参数，即要锁定和解锁的对象
1、如果synchronized明确指定了锁对象，比如synchronized(变量名)、synchronized(this)等，说明加解锁对象为该对象
2、如果没有明确指定
若synchronized修饰的方法为非静态方法，表示此方法对应的对象为锁对象
若synchronized修饰的方法为静态方法，则表示此方法对应的类对象为锁对象





aqs(AbstractQueuedSynchronizer类)是一个用来构建锁和同步器的框架，各种lock包中的锁都是基于aqs来构建
aqs内部有三个核心组件 state表示加锁状态，初始值为0 获取锁的线程  阻塞队列

可重入锁reentrantlock的实现原理是什么
可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己，是的话state+1，释放锁的时候就将state-1。当state减到0的时候就去唤醒阻塞队列的第一个线程。


ReentrantLock 的实现原理
从这三个方面回答
什么是 ReentrantLock
ReentrantLock 的特性
ReentrantLock 的实现原理

定义：ReentrantLock 是一种可重入的排它锁，主要用来解决多线程对共享资源竞争的 问题
特性：
支持可重入，也就是获得锁的线程在释放锁之前再次去竞争同一把锁的时候，不需要加锁就可以直接访问。
支持公平和非公平特性。
它提供了阻塞竞争锁和非阻塞竞争锁的两种方法，分别是 lock()和 tryLock()。
实现原理：
锁的竞争的时候，ReentrantLock 是通过互斥变量，使用 CAS 机制来实现的，
没有竞争到锁的线程，使用aqs队列存储，底层是通过双向链表来实现的。当锁被释放之后，会从 AQS 队列里面的头部唤醒下一个等待锁的线程。
公平和非公平的区别主要是体现在竞争锁的时候，是否需要判断 AQS 队列存在
等待中的线程。
锁的重入特性，在 AQS 里面的state来保存当前获得锁的线程次数，当同一个线程下次再来竞争锁的时候，直接增加重 入次数



7.什么是CAS机制
CAS 是 Java 中 Unsafe 类里面的方法
它的主要功能是能够保证在多线程环境下，对于共享变量的修改的原子性。
一般在多线程环境下，会存在原子性的问题时我们加同步锁来解决原子性问题，但是加同步锁，会带来性能上的损耗
我们就可以使用 CAS 机制来进行优化
我们可以调用了 unsafe 类中的 compareAndSwapInt()方法来 达到同样的目的，这个方法有四个参数，
分别是:当前对象实例、成员变量 state 在内存地址中的偏移量、预期值 0、期望更改 之后的值 1。

CAS 机制会比较 state 内存地址偏移量对应的值和传入的预期值 0 是否相等，如果相等， 就直接修改内存地址中 state 的值为 1，否则，返回 false，
表示修改失败，而这个过程是原子的，不会存在线程安全问题
是如何保证原子性的
CompareAndSwap 的底层实现中，在多核 CPU 环境下，会增加一个 Lock 指令对缓存或者总线加锁，从而保证比较并替换这两个指令的原子性。


什么是乐观锁
每次获取数据的时候都认为别人不会修改，所以不会上 锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制实现


什么是自旋锁？
自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。



简述synchronized和java.util.concurrent.locks.Lock的异同？

synchronized是关键字，通过把关键字修饰在方法层面或代码块层面来控制锁的粒度，锁的释放是被动的，当修饰的代码执行完或出现异常才会被释放，无法实现非阻塞竞争锁的方法 ，
只提供了一种非公平锁

lock是juc包提供的接口，通过lock和unlock方法来控制锁的粒度，锁的释放由自己决定，提供非阻塞竞争锁的方法trylock方法，还提供公平锁和非公平锁的机制







死锁是怎么导致的
当不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。

导致死锁的条件有四个，同时满足四个条件会造成死锁
互斥条件：共享资源x和y只能被一个线程占用
请求和保持条件：线程torrent1已经取得共享资源x，在等待共享资源y的时候，不释放共享资源x
不可抢占条件：其他线程不能强行抢占线程t1占有的资源
循环等待条件：线程torrent1等待线程torrent2占有的资源，线程torrent2等待线程t1占有的资源就是循环等待


如何去避免死锁
只能通过重启服务或者kill掉这个线程
所以我们只能在写代码的时候去规避可能出现死锁的问题
而按照死锁发生的四个条件，我们只需要破坏其中的任意一种就可以解决
但是互斥条件没办法破坏，因为他是互斥锁的基本约束，所以我们可以通过其他三个条件来破坏
对于请求和保持条件，我们可以一次性申请所有的资源，这样就不存在锁要等待了
对于不可抢占条件，占用部分资源的线程，在进一步申请其他资源的时候，如果申请不到，我们可以主动去释放它占有的资源 ，这样不可抢占条件就被破坏掉了
对于循环等待条件，可以按序申请资源来预防，按序申请资源是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，然后再去申请资源序号大的，这样线性话后，自然就不存在循环了



什么是读写锁
读写锁是一对互斥锁
让一个线程在进行读操作时，不允许其他线程的写操作，但是不影响其他线程的读操作
当一个线程在进行写操作时，不允许任何线程进行读操作或者写操作


什么是公平锁，什么是非公平锁
他们的底层都是使用aqs来进行排队，他们的区别在于线程在使用lock方法加锁时
如果是公平锁，会先检查aqs队列中是否存在线程在排队，如果有线程在排队，则当前线程也进行排队
如果是非公平锁，则不会去检查是否有线程在排队，而是直接竞争锁
synchronized是非公平锁，reentrantlock是公平锁也可以是非公平锁，在实例化的时候去指定公平还是非公平



~`````````````````````````````````````````````````````````````````````~~~~`
多线程


11.线程池七大参数
核心线程数：线程池中的基本线程数量

最大线程数：线程池允许的最大线程数

最大线程的存活时间：当阻塞队列的任务执行完后，最大线长的回收时间

最大线程的存活时间单位

阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列

线程工厂：用于生产线程

handler（拒绝策略）：中止策略(默认的拒绝策略)、抛弃策略、抛弃最老策略、调用者运行策略(不会抛弃任务，也不会抛出异常，而是将任务回退到调用者)



线程池运行原理
任务被提交到线程池，会先判断当前线程数量是否小于核心线程数，如果小于则创建线程来执行提交的任务，否则将任务放入阻塞队列，
如果阻塞队列满了，则判断当前线程数量是否小于最大线程数,如果小于则创建线程执行任务，否则就会调用拒绝策略。



如何回收线程？

工作线程启动后，就进入runWorker方法，里面是一个while循环，循环判断任务是否为空：

若不为空，执行任务；
若超过指定时间仍取不到任务，或发生异常，退出循环，执行processWorkerExit(泼)将工作线程移除掉。



16.ThreadLocal原理
原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。
但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，
可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value



线程有几种状态

 就绪(Runnable):线程准备运行，不一定立马就能开始执行。
 运行中(Running):进程正在执行线程的代码。
 等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。
 睡眠中(Sleeping):线程被强制睡眠。
 I/O 阻塞(Blocked on I/O):等待 I/O 操作完成。
 同步阻塞(Blocked on Synchronization):等待获取锁。
 死亡(Dead):线程完成了执行。


线程状态，BLOCKED 和 WAITING 有什么区别
BLOCKED 和 WAITING 都是属于线程的阻塞等待状态
BLOCKED 是锁竞争失败后被被动触发的状态，WAITING 是人为的主动触发的状 态
BLCKED 的唤醒时自动触发的，而 WAITING 状态是必须要通过特定的方法来主动 唤醒



线程池异常如何处理
1、try-catch捕获异常
2、重新threadpoolexecutor.afterexcute方法，处理传递的异常引用
2、submit执行，future.get接受异常



什么是CompletableFuture
是java8引用的一个组件，可以解决异步执行任务和处理异步任务的结果，可以让我们将一个耗时的任务提交给线程池来进行异步处理，
然后可以继续执行其他任务，等到异步任务执行结束后会触发一个回调方法，我们可以在回调方法里面去处理异步任务的执行结果，
在它出现之前我们只能使用callable/future这样的一个机制来去获取异步线程的执行结果，但是future是通过阻塞等待的方式来实现的，对性能不是很好

supplyAsync是创建带有返回值的异步任务
 CompletableFuture<String> articleCompletableFuture = CompletableFuture.supplyAsync(() -> {}, threadPoolExecutor);


thenAcceptAsync表示某个任务执行完成后执行的动作，即回调方法
articleCompletableFuture.thenAcceptAsync


runAsync是创建没有返回值的异步任务
CompletableFuture.runAsync



thenAccep和thenAccepAsync区别在于，使用thenAccep方法时子任务与父任务使用的是同一个线程，而thenAccepAsync在子任务中可能是另起一个线程执行任务，
并且thenAccepAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。


用来实现多任务的并行执行（最后使用）
 CompletableFuture.allOf


线程池如何知道一个线程的任务已经执行完成
1、线程池提供了一个 isTerminated(is 特美内的)方法，可以判断线程池的运行状态，我们可 以循环判断 isTerminated()方法的返回结果来了解线程池的运行状态，
通过这个方法获取状态的前提是，程序中主动调用了线程池的 shutdown() 方法
2、在线程池中，有一个 submit()方法，它提供了一个 Future 的返回值，我们通 过 Future.get()方法来获得任务的执行结果，当线程池中的任务没执行完之前，
future.get()方法会一直阻塞，直到任务执行结束，因此，只要 future.get() 方法正常返回，也就意味着传入到线程池中的任务已经执行完成了



为什么使用mq
异步、解耦、削峰
削峰：例如出现请求峰值的情况，由于消费者的消费能力有限，会按照自己的节奏来消费消息，多的请求不处理，保留在mq的队列中，不会对系统的稳定性造成影响。保证了系统的稳定性



什么是正向代理什么是反向代理
正向代理它位于客户端和服务端之间，代表客户端向其他服务器发送请求。
一般使用的场景就是，当客户端无法直接访问某些资源时，可以通过正向代理来访问，例如vpn代理

反向代理是作为服务器端的代理，而不是作为客户端的代理，用于隐藏真实服务端。




类加载机制






并发操作

下单接口
a线程进来获取redis库存 5个
进行自减操作 变4个



取消订单接口
b线程进来获取redis库存 5个
理论上进行自增操作 变6个

实际进行自增操作 变5个  ？？？？？？


如果自减先开始 5
4   扣减库存结果
5   扣减回滚结果


如果自增先开始 5
6   扣减回滚结果
5   扣减库存结果







